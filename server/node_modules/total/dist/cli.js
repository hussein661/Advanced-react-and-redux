#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
require('module-alias/register');
const getStdin = require('get-stdin');
const path = require("path");
const pck = require(path.join(__dirname, '../package.json'));
const command_1 = require("lib/command");
const program = require("commander");
(() => __awaiter(this, void 0, void 0, function* () {
    const [stdin, commands] = yield Promise.all([getStdin(), command_1.loadCommands()]);
    commands.forEach(registerCommand.bind(this, stdin));
    program.version(pck.version).parse(process.argv);
}))();
function registerCommand(stdin, Command) {
    const command = new Command();
    const config = command.config();
    const programState = program
        .command(config.name)
        .description(config.description);
    for (const option of config.options) {
        programState.option(option.flags, option.description);
    }
    programState.action((commander) => {
        const argsPassed = config.options
            .filter((op) => commander[op.name])
            .map((op) => (Object.assign({}, op, { ['value']: commander[op.name] })));
        command
            .onRun(stdin, argsPassed)
            .catch((err) => console.log(err.message))
            .then((result) => result !== undefined ? console.log(result) : programState.help());
    });
}
